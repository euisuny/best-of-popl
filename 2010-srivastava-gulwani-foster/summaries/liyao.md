This paper proposes an approach to program synthesis leveraging
existing verification tools (automated theorem provers).

A common approach in program verification is to extract verification
conditions that can be passed to a solver. The key idea is that
we can generalize that approach by adding unknowns for the program statements
themselves, with extra constraints on those unknown.

The inputs of the synthesis problem are:

1. A functional specification given as a pre/post-condition pair.
2. Constraints on the syntax of individual expressions (RHS of assignments) and guards (conditionals).
3. Resource constraints
    a. Flowgraph template: determines the shape of the control-flow graph,
       which basically fixes how while loops are nested and sequenced.
       For example, a template ((o*)* o*) describes two nested loops followed
       by a simple loop.
    b. Constraints on the number of variables and operations used.

Synthesis first expands the flowgraph template, generating unknowns for
loop bodies and conditionals, then generates constraints encoding
partial correctness, well-formedness (i.e., that the solution corresponds to
a program), and termination.

Some technical requirements are given for solvers to be applicable to
the resulting verification problems and although most existing tools
do not satisfy them, they give some rough intuitions as to why those are
desirable properties that might be met as the technology gets more
sophisticated.

They then present some experimental results, which seem quite impressive
to be generated by a synthesis tool: Strassen, Bresenham, merge sort, quicksort
to name some. One other example I found interesting was the variations on the
integral square root under different constraints.

---

Q. How do they account for intermediate variables?
   Acyclic fragments are encoded as a conjunction of
   equalities (xi' = ei) which model assignments, but
   for example couldn't you solve "swap two variables"
   with (x' = y /\ y' = x), which requires a temporary
   when translated into sequential code?

Q. There is a strong "proofs as programs" flavor but I still wonder,
   how deep is the connection to Curry-Howard?
